<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    /*
        使用Symbol方法生成一个SYmbol的变量
        并且具有唯一性
        不可转化为其他数据类型
    */
    let s1 = Symbol('s1');
    let s2 = Symbol('s2');
    console.log(s1 == s2);

    let s3 = Symbol("s1");
    let obj = {};
    obj[s1] = "hello";
    let obj1 = {
        [s1]:"world"
    }

    let obj2 = {};
    let s4 = Symbol('s2');
    Object.defineProperty(obj2,s4,{
        value: 4
    });

    Object.getOwnPropertySymbols(obj2);



    let f1 = Symbol("f1");
    console.log(Symbol.for("f1") == f1);//false
    console.log(Symbol.for("f1") == Symbol.for("f1"));//true

    let s1 = new Set ([1,2,3,"hello",5,6,1,2,3]);
    console.log(s1[0]);
    for(let i of s1.values())
    {
        console.log(i);
    }
    for(let i of s1)
    {
        console.log(i);
    }
    console.log(s1.size);
    s1.add(1);
    s1.delete("hello");


    let m1 = new Map();
    let o = {"x":1};
    m1.set(o,2);
    console.log(m1);
    m1.get(o);
    m1.has(o);
    
    for(let i of m1)
    {
        console.log(i);
    }

    for(let i of m1){
        console.log(i);
    }


    /*
            使用Symbol方法生成一个Symbol的变量
            并且具有唯一性
            不可转化为其他数据类型
        */
        let s1=Symbol("s1");
        let s2=Symbol("s2");
        console.log(s1==s2); 

        let obj={};
        obj[s1]="hello";//希望s1为变量，用[]
        obj.s1;

        let obj1={
            [s1]:'hello'
        }
        let obj2={};

        let s3=Symbol("s3");
        Object.defineProperty(obj2,s3,{
            value:2
        });

        Object.getOwnPropertySymbols(obj2);

        console.log(Symbol.for("foo")==Symbol.for("foo"));//true
        console.log(Symbol("foo")==Symbol("foo"));//false
        console.log(Symbol.for("foo")==Symbol("foo"));//false


        let s4=new Set([1,2,'hello',3,5,4,6,1,2,3]);
        for (let j of s4.values()) {
            console.log(j);   
        }
        console.log(s4);//去掉重复元素
        for (let i of s4) {
            console.log(i);   
        }
        console.log(s4.size);
        s4.add(1);
        s4.delete("hello");
        s4.has(5);
        console.log(s4.keys());
        console.log(s4);


        let m1=new Map();
        let obj3={"x":1};
        m1.Set(obj2,3);
        m1.get(obj3);
        m1.has(obj3);
        m1.delete(obj3);
        console.log(m1);
        for (let i of m1) {
            console.log(i);   
        }


        let m2=new Map([//二维数组
            ["username","zhangsan"],
            ["age",20]
        ]);
        for (let i of m2) {
            console.log(i);   
        }

        //第一种
        function Point(x,y) {
            this,x=x;
            this.y=y;
        }
        Point.prototype.show=function(){
            console.log(this.x);
        }
        let p1=new Point(1,2);
        p1.show();
        //第二种
        class Point{
            constructor(){
                this,x=x;
                this.y=y;
            }
            show(){
                console.log(this.x);
            }
            showY(){
                console.log(this.y);
            }
        }
        let p1=new Point(1,2);
        p1.show();
        console.log(typeof Point);
        let p2=new Point(3,4);  
        console.log(p1._proto_==p2._proto_);
        console.log(p1._proto_==p2.prototype);
        p2.show();

        /*
            通过static进行定义
            静态方法内this指向类本身
        */
        class Person{
            static walk(){
                console.log(this);
            }
            say(){
                console.log(this);
            }
        }
        let p3=new Person();
        p3.say();   //只能调用say方法
        Person.walk();  //静态方法，只能通过类来调用

      
        let obj4={x:1};
        let obj5=Object.create(obj4);
        let obj6={};
        obj6._proto_=obj4;



        function Parent(x,y){
            this,x=x;
            this.y=y;
        }
        function Child(x,y,z){
            Parent.call(this,x,y);
            this.z=z;
        }
        let c1=new Child(1,2,3);
        console.log(c1);

        class Parent{
            constructor(x,y){
                this.x=x;
                this.y=y;
            }
        }
        /*
            super在子函数的构造函数中，可以指向父类的构造对象
        */
        class Child extends Parent{
            constructor(x,y,z){
                super()(x,y);
                this.z=z;
            }
        }
        let c1=new Child(1,2,3);
        console.log(c1);

</script>
</html>